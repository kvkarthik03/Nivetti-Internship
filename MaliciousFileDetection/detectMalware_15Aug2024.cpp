/* Program for Malicious File Detection
Author - K V Karthik (RVCE)
Mentor - Aravind (Nivetti Systems)
Date - 15/08/24
*/
#include <iostream>
#include <pcapplusplus/Packet.h>
#include <pcapplusplus/TcpLayer.h>
#include <pcapplusplus/PcapFileDevice.h>
#include <string>
#include <openssl/evp.h>
#include <openssl/err.h>
#include <iomanip>
#include <sstream>
#include <curl/curl.h>
#include <nlohmann/json.hpp>

// OTX API key - Need to be filled before running the program
std::string API_KEY = "";

// Function to handle response data from curl
static size_t WriteCallback(void* contents, size_t size, size_t nmemb, void* userp)
{
    ((std::string*)userp)->append((char*)contents, size * nmemb);
    return size * nmemb;
}

// Function to query AlienVault OTX API with the hash
std::string queryOTX(const std::string& hash)
{
    CURL* curl;
    CURLcode res;
    std::string readBuffer;

    curl = curl_easy_init();
    if(curl) {
        std::string url = "https://otx.alienvault.com/api/v1/indicators/file/" + hash + "/general";
        
        struct curl_slist *headers = NULL;
        headers = curl_slist_append(headers, ("X-OTX-API-KEY: " + API_KEY).c_str());

        curl_easy_setopt(curl, CURLOPT_URL, url.c_str());
        curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);
        curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, WriteCallback);
        curl_easy_setopt(curl, CURLOPT_WRITEDATA, &readBuffer);
        
        // Perform the request, res will get the return code
        res = curl_easy_perform(curl);
        
        // Check for errors
        if(res != CURLE_OK) {
            std::cerr << "curl_easy_perform() failed: " << curl_easy_strerror(res) << std::endl;
        }
        
        // Clean up
        curl_easy_cleanup(curl);
    }

    return readBuffer;
}

// Function to parse JSON response
void parseOTXResponse(const std::string& response)
{
    try {
        auto jsonResponse = nlohmann::json::parse(response);
        
        // Check if pulse_info contains pulses (malware information)
        if (jsonResponse.contains("pulse_info") && !jsonResponse["pulse_info"]["pulses"].empty()) {
            std::cout << "Malware detected! Details:" << std::endl;
            
            // Loop through the pulses (which are indicators of malware)
            for (const auto& pulse : jsonResponse["pulse_info"]["pulses"]) {
                std::cout << "Name: " << pulse["name"] << std::endl;
                std::cout << "Description: " << pulse["description"] << std::endl;
                std::cout << "Created: " << pulse["created"] << std::endl;
                std::cout << "----------------------------------" << std::endl;
            }
        } else {
            std::cout << "File is clean." << std::endl;
        }
    } catch (const std::exception& e) {
        std::cerr << "Error parsing JSON: " << e.what() << std::endl;
    }
}

// Function to compute SHA-256 hash of a string using EVP
std::string computeSHA256(const std::string& data)
{
    EVP_MD_CTX* mdctx = EVP_MD_CTX_new();
    if (!mdctx)
    {
        std::cerr << "Error creating EVP_MD_CTX" << std::endl;
        return "";
    }

    if (1 != EVP_DigestInit_ex(mdctx, EVP_sha256(), NULL))
    {
        std::cerr << "Error initializing digest" << std::endl;
        EVP_MD_CTX_free(mdctx);
        return "";
    }

    if (1 != EVP_DigestUpdate(mdctx, data.c_str(), data.size()))
    {
        std::cerr << "Error updating digest" << std::endl;
        EVP_MD_CTX_free(mdctx);
        return "";
    }

    unsigned char hash[EVP_MAX_MD_SIZE];
    unsigned int hash_len;
    if (1 != EVP_DigestFinal_ex(mdctx, hash, &hash_len))
    {
        std::cerr << "Error finalizing digest" << std::endl;
        EVP_MD_CTX_free(mdctx);
        return "";
    }

    EVP_MD_CTX_free(mdctx);

    std::stringstream ss;
    for (unsigned int i = 0; i < hash_len; ++i)
    {
        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];
    }
    return ss.str();
}

int main() {
    // Open the pcap file
    pcpp::IFileReaderDevice* reader = pcpp::IFileReaderDevice::getReader("Wireshark-tutorial-extracting-objects-from-a-pcap-1-of-5.pcap");

    if (!reader || !reader->open()) {
        std::cerr << "Cannot open input pcap file for reading" << std::endl;
        return 1;
    }

    pcpp::RawPacket rawPacket;
    while (reader->getNextPacket(rawPacket)) {
        pcpp::Packet parsedPacket(&rawPacket);

        if (parsedPacket.isPacketOfType(pcpp::TCP)) {
            pcpp::Layer* tcpLayer = parsedPacket.getLayerOfType<pcpp::TcpLayer>();
            if (tcpLayer) {
                // Get the entire payload
                uint8_t* payload = tcpLayer->getLayerPayload();
                int payloadSize = tcpLayer->getLayerPayloadSize();

                // Print the payload as raw data (byte by byte)
                // std::cout << "Raw TCP Payload (size " << payloadSize << " bytes):" << std::endl;
                // for (int i = 0; i < payloadSize; ++i) {
                //     std::cout << std::hex << (int)payload[i] << " ";
                // }
                std::cout << std::endl;

                // If the payload is text, print it as a string
                std::string payloadStr((char*)payload, payloadSize);
                // std::cout << "Payload as string: " << payloadStr << std::endl;
                std::string hash = computeSHA256(payloadStr);
                std::cout << "File Hash: " << hash << std::endl;

                std::string response = queryOTX(hash);
                parseOTXResponse(response);

                // Separate each packet for clarity
                std::cout << "-------------------------------------" << std::endl;
            }
        }
    }

    reader->close();
    return 0;
}
